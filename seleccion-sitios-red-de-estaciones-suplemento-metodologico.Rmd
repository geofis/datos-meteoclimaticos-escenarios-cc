---
title: "Selección de sitios para el establecimiento de una red de estaciones meteoclimáticas usando AHP y análisis de autocorrelación espacial. Suplemento metodológico"
author: "José Martínez<br>Michela Izzo"
output:
  # bookdown::github_document2:
  #   number_sections: false
  #   fig_caption: yes
  bookdown::html_document2:
    number_sections: false
    code_folding: hide
    fig_caption: yes
    md_extensions: "-fancy_lists"
editor_options: 
  chunk_output_type: console
always_allow_html: true
references: ref/biblio.bib
bibliography: ref/biblio.bib
---

```{r supsetup, include=FALSE}
knitr::opts_chunk$set(
  cache = F, 
  echo = TRUE,
  warning = FALSE,
  message = FALSE)
# options(digits = 3)
```

`r if(knitr::opts_knit$get("rmarkdown.pandoc.to") == 'gfm-yaml_metadata_block') 'Versión HTML (más legible e interactiva), [aquí](https://geofis.github.io/datos-meteoclimaticos-escenarios-cc/ponderacion-variables-ahp.html)'`

`r if(knitr::opts_knit$get("rmarkdown.pandoc.to") == 'latex') 'Versión HTML (quizá más legible), [aquí](https://geofis.github.io/datos-meteoclimaticos-escenarios-cc/ponderacion-variables-ahp.html)'`

## Suplemento metodológico para la selección de sitios para el establecimiento de una red de estaciones meteoclimáticas usando AHP y análisis de autocorrelación espacial

```{r suppaquetes}
library(kableExtra)
library(tidyverse)
library(ahpsurvey)
estilo_kable <- function(df, titulo = '', cubre_anchura = T) {
  df %>% kable(format = 'html', escape = F, booktabs = T, digits = 2, caption = titulo) %>%
  kable_styling(bootstrap_options = c("hover", "condensed"), full_width = cubre_anchura)
}
```

### Escalas de valoración y matriz de comparación por parejas

```{r supvariables}
variables <- c(
    acce = "distancia a accesos",
    temp = "estacionalidad térmica",
    pluv = "estacionalidad pluviométrica",
    habi = "heterogeneidad de hábitat",
    agua = "distancia a cuerpos de agua",
    pend = "pendiente",
    inso = "horas de insolación",
    elev = "elevación"
)
col_ord <- as.vector(sapply(as.data.frame(combn(names(variables), 2)), paste0, collapse = '_'))
```

El método AHP consiste en descomponer un problema complejo en una estructura jerárquica de criterios y subcriterios, que consisten en variables o atributos del terreno en nuestro caso, y luego comparar las alternativas en función de cada uno de estos criterios. Los variables se comparan en parejas (o pares, comparación pareada), en la que se asigna un valor numérico a la importancia relativa de cada criterio en relación con los demás. La evaluación pareada se realiza para cada par único de variables; así, el número de comparaciones posibles es $\frac{N(N-1)}{2}$

En nuestro caso, dado que comparamos 8 atributos (variables) en parejas, realizamos un total de $(8\times7)/2=28$ comparaciones. Los atributos seleccionados fueron *`r paste(as.vector(variables), collapse = ', ')`*. Para evitar errores de redundancia y garantizar un diseño sistemático y eficiente, empleamos Formularios de Google al cual titulamos como ["Formulario de comparación pareada de criterios de identificación de sitios idóneos para una red de observación climática"](https://docs.google.com/forms/d/e/1FAIpQLScOx1bxW47LLEPQ_A6lHmSnpOQkUyHEoLJsRIKBNlbfQby5Dw/viewform?usp=sf_link). Programamos en Python las posibles comparaciones por pares y, seguidamente, a través de la API del Google Workspace, enviamos el diseño para su puesta en línea. Un total de nueve personas del área de climatología, análisis de datos y geografía física, rellenaron el formulario.

Para procesar los resultados de las consultas y generar una tabla de preferencias global con la cual construimos los pesos, en primer lugar generamos una tabla (no confundir con la matriz de comparación por parejas) donde cada columna es una comparación de dos atributos, por ejemplo A y B. Dado que la escala de valoración por parejas del método AHP, en sentido estricto, se apoya en ecuaciones lineales, en el fondo se utiliza una escala ordinal basada en un gradiente, que en el método original, usa números enteros 1 al 9. Esto significa que, al asignar "1", estamos indicando que los criterios comparados, por ejemplo, A y B, tienen la misma importancia. Del 2 al 9, el criterio B tiene mayor importancia, de manera creciente, que el A. Por otra parte, el grado de importancia de A sobre B se denota por medio de recíprocos `{1/2 , 1/3, ..., 1/8, 1/9}` y usando un gradiente inverso, es decir, la fracción más pequeña (`1/9`) indica mayor importancia relativa para el criterio A. Para denotar las valoraciones complementarias, el paquete `ahpsurvey` permite usar opuestos `{-2, -3, ..., -8, -9}`, que luego son recodificados a recíprocos en la matriz de comparación por parejas; preferiremos esta opción, es decir, usar opuestos, porque nos facilitó la recodificación con expresiones regulares.

Luego de recoger las valoraciones realizadas por medio de consultas en una tabla, el siguiente paso consistió en obtener la matriz de comparación por parejas, que tiene la siguiente forma:

$$ \mathbf{S_k} =\begin{pmatrix}
                      a_{1,1} & a_{1,2} & \cdots & a_{1,N} \\
                      a_{2,1} & a_{2,2} & \cdots & a_{2,N} \\
                      \vdots  & \vdots  & a_{i,j} & \vdots  \\
                      a_{N,1} & a_{N,2} & \cdots & a_{N,N}
                      \end{pmatrix} $$

donde $a_{i,j}$ representa la comparación del atributo $i$ y $j$. Tal como se ha comentado, si $i$ es más importante que $j$ en 6 unidades, $a_{i,j} = 6$ y $a_{j,i} = \frac{1}{6}$, es decir, el recíproco. Los datos de las comparaciones deben organizarse en esta forma matricial para realizar los análisis subsiguientes.

### Recodificación de valores y de nombres de columnas

En el estudio, utilizamos una escala modificada basada en sólo 7 posibles puntuaciones, recodificamos las puntuaciones de formulario de la siguiente manera: el valor 0 a 1 (usamos 0 en los formularios para facilitar la comprensión de la escala a los encuestados); los valores 33%, 66% y 100%, los distribuimos en el rango 2 a 9 de la siguiente manera:

```{r suptabequivalencias}
valor_formulario <- c('(100)', '(66)', '(33)', '0', '33', '66', '100')
recod_repartida <- FALSE
if(recod_repartida) {
    recodificado_ahp <- round(c(0-(2+3*((9-2)/3)), 0-(2+2*((9-2)/3)), 0-(2+((9-2)/3)),
                              1,
                              2+((9-2)/3), 2+2*((9-2)/3), 2+3*((9-2)/3)
                              ),
                            2)

} else {
  recodificado_ahp <- c(-9, -6, -3,
                        1,
                        3, 6, 9)
}
data.frame(
  `Valor en formulario` = valor_formulario,
  `Recodificado a escala AHP original` = recodificado_ahp,
  check.names = F) %>% 
  kable(format = 'html', escape = F, booktabs = T,
        caption = 'Tabla de recodificación de puntaciones de formulario a escala AHP original') %>%
  kable_styling(bootstrap_options = c("hover", "condensed"), full_width = T)
```

Por otro lado, creamos un "diccionario" (vector nombrado `variables`) de equivalencias entre los nombres largos de columnas de la tabla de resultados (que provienen escritas en el lenguaje natural de los formularios) y nombres cortos de cuatro caracteres. Este diccionario lo utilizamos para recodificar los nombres de las columnas de la tabla de respuestas a nombres cortos, con lo cual mejoramos la legibilidad de las representaciones gráficas y las impresiones de tablas y matrices de resultados.

```{r supimpresiontabequivalencias}
as.data.frame(variables) %>% 
  rownames_to_column() %>% 
  setNames(nm = c('Código', 'Nombre completo')) %>% 
  kable(format = 'html', escape = F, booktabs = T,
        caption = 'Tabla de equivalencias de nombres de las variables evaluadas') %>%
  kable_styling(bootstrap_options = c("hover", "condensed"), full_width = T)
```

Con la tabla de equivalencias de puntuaciones y el diccionario de nombres, recodificamos programáticas las respuestas obtenidas en los formularios a la escala original del método AHP, así como los nombres de columnas de la tabla de respuestas de comparación de atributos. En primer lugar, mostramos cómo realizamos la recodificación de puntuaciones.

La tabla de resultados de las puntuaciones en bruto (anonimizada), obtenida a partir del rellenado en Google Forms por parte de 9 consultados, se muestra a continuación.

```{r suptablaresultadosenbruto}
tabla_original <- read_csv('fuentes/respuestas-ahp/respuestas.csv')
tabla_en_bruto <- tabla_original[, -grep('Marca|Opcionalmente', colnames(tabla_original))]
tabla_en_bruto %>% 
    kable(format = 'html', escape = F, booktabs = T,
        caption = 'Tabla de resultados en bruto (anonimizada) obtenida a partir del rellenado del "Formulario de comparación pareada de criterios de identificación de sitios idóneos para una red de observación climática"') %>%
  kable_styling(bootstrap_options = c("hover", "condensed"), full_width = T)
```

Utilizamos una forma muy eficiente de recodificar, que consistió en aplicar expresiones regulares a las respuestas originales para extraer el valor de interés (e.g. "33"), y luego empleamos la función `match` para asociar dicha puntuación con su correspondiente valor en la escala AHP original.

```{r suptablaresultadosrecodificados}
tabla_recodificada <- sapply(
  tabla_en_bruto[, grep('^Valora.*', colnames(tabla_en_bruto))],
  function(x){
   sustituido <- gsub('(^[0-9]*|\\([0-9]*\\)):.*', '\\1', x)
   # paste(sustituido, '=', reescalado[match(sustituido, valor_formulario)]) #For testing
   recodificado_ahp[match(sustituido, valor_formulario)]
  })
tabla_recodificada %>% 
    kable(format = 'html', escape = F, booktabs = T,
        caption = 'Tabla de puntaciones recodificadas') %>%
  kable_styling(bootstrap_options = c("hover", "condensed"), full_width = T)
```

En segundo lugar, aplicamos la recodificación de nombres de columnas de la tabla de respuestas, que originalmente eran transcripciones de las preguntas del formulario de Google. Este paso nos ayudó a representar nombres más cortos en la tabla que posteriormente usamos como insumo (ver tabla \@ref(tab:suptablaresultadosparamatrizpareada)) para crear la matriz de comparación por parejas del método AHP.

```{r suptablaresultadosparamatrizpareada}
tabla_col_renom <- tabla_recodificada
cambiar_nombre_por_variable <- function(primera=T) {
  names(
    variables[match(
      gsub('(^.*variables )(.*?)( y )(.*$)',
           ifelse(primera, '\\2', '\\4'),
           colnames(tabla_col_renom)),
      variables)])
}
colnames(tabla_col_renom) <- paste0(
  cambiar_nombre_por_variable(),
  '_',
  cambiar_nombre_por_variable(primera = F)
)
tabla_col_renom %>% 
  kable(format = 'html', escape = F, booktabs = T,
        caption = 'Tabla de columnas renombradas (adaptada para la generación de  la matriz de comparación en parejas)') %>%
  kable_styling(bootstrap_options = c("hover", "condensed"), full_width = T)
```

El conjunto de datos de la tabla \@ref(tab:suptablaresultadosparamatrizpareada) recoge las respuestas dadas por las 9 personas consultada, cada una compuesta por 28 comparaciones en parejas de criterios (8 criterios). Analicemos algunos ejemplos para ilustrar el flujo seguido en la recodificación y los cambios de nombres de columnas de la tabla de resultados.

La primera fila contiene las valoraciones realizadas por la persona consultada número 1. En la primera pregunta, "*Valora la importancia relativa de las variables horas de insolación y elevación*", el consultado respondió "*33: Importancia moderada para elevación*" (ver tabla \@ref(tab:suptablaresultadosenbruto)). Dicha valoración fue recodificada a puntuaciones AHP con el valor `r as.vector(tabla_col_renom[1, 1])` (ver tabla \@ref(tab:suptablaresultadosrecodificados)); nótese que el valor recodificado es positivo, dado que el criterio que recibió la mayor importancia fue el que ocupaba la segunda posición en la pregunta.

Finalmente, tras realizar el renombrado, la columna en cuestión paso de nombrarse "*Valora la importancia relativa de las variables horas de insolación y elevación*" a `inso_elev` (ver tabla \@ref(tab:suptablaresultadosparamatrizpareada)). Esta cambio nos permitirá manejar atributos cortos en la matriz de comparación por parejas.

Ilustremos el uso del signo con otro ejemplo. Observemos la respuesta de la persona 1 a la octava pregunta ("*Valora la importancia relativa de las variables heterogeneidad de hábitat y horas de insolación*"). Notaremos que su respuesta fue "*(33): Importancia moderada para heterogeneidad de hábitat*", dando mayor importancia al criterio que ocupa la primera posición. Esta valoración se recodificó a `r as.vector(tabla_col_renom[1, 8])` (negativo) en la escala AHP, y la columna fue renombrada a `habi_inso`. La recodificación valores y de nombres de columnas es un paso crítico del AHP, porque es común la comisión de errores que terminan "colándose" hacia insumos del análisis. Es además el paso previo a la construcción de una matriz de comparación en parejas consistente, que es el insumo principal del AHP.

### Generación de la matriz de comparación en parejas

Este paso resultó relativamente fácil, puesto que en pasos posteriores se elaboraron los insumos que necesita la función `ahp.mat` del paquete `ahpsurvey`. Es importante remarcar una particularidad sobre el orden las columnas. El parámetro `atts` de la función `ahp.mat` debe contener un vector con los nombres de los atributos comparados, en nuestro caso, las 8 variables ya mencionadas. El orden de este vector es muy importante, pues la función `ahp.mat` espera que las columnas de la tabla fuente se encuentren en el siguiente orden: `atributo1_atributo2`, `atributo1_atributo3`, ..., `atributo1_atributo8`, `atributo2_atributo3`, `atributo2_atributo4`, ..., `atributo2_atributo8`, ..., `atributo7_atributo8`. Este objeto ya fue creado arriba mediante la función `combn`, y fue nombrado como `col_ord`. Por lo tanto, reordenaremos las columnas de la tabla de respuestas recodificadas usando dicho vector.

```{r supmatrizahp, results='asis'}
matriz_ahp <- tabla_col_renom[, col_ord] %>%
  ahp.mat(atts = names(variables), negconvert = TRUE)
map(matriz_ahp,
  ~ kable(x = .x, format = 'html', escape = F, booktabs = T, digits = 2) %>%
  kable_styling(bootstrap_options = c("hover", "condensed"), full_width = T)
)
```

Como primera evaluación de la calidad de la matriz de comparación en parejas, calculamos las preferencias de ponderación individuales de los consultados, para generar una tabla resumen con los pesos de preferencia de cada consultado. Este cálculo se realiza normalizando las matrices para que todas las columnas sumen 1, y luego se calculan los promedios por filas como los pesos de preferencia de cada atributo. Los promedios se pueden obtener de 4 formas posibles: media aritmética, media geométrica, media cuadrática y vector propio (*eigen vector*).

Usando las diferencias de los promedios de preferencias individuales, evaluamos las diferencias máximas entre métodos, como forma indirecta de determinar si existe consistencia en las valoraciones dadas por cada personas consultada; diferencias máximas mayores de 0.05 se consideran, a priori, dignas de escrutinio posterior (ver figura \@ref(fig:supdiferenciasmaximas)).

```{r supdiferenciasmaximas, fig.cap='Diferencias de los promedios de preferencias individuales entre los métodos "media aritmética" y "valor propio"'}
eigentrue <- ahp.indpref(matriz_ahp, atts = names(variables), method = "eigen")
geom <- ahp.indpref(matriz_ahp, atts = names(variables), method = "arithmetic")
error <- data.frame(id = 1:length(matriz_ahp), maxdiff = apply(abs(eigentrue - geom), 1, max))
error %>%
  ggplot(aes(x = id, y = maxdiff)) +
  geom_point() +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "red") +
  geom_hline(yintercept = 0, color = "gray50") +
  scale_x_continuous(breaks = seq_len(nrow(tabla_col_renom)), "ID de persona consultada") +
  scale_y_continuous("Diferencia máxima") +
  theme_minimal()
```

En este caso, la persona consultada número 3 parece haber aportado respuestas inconsistentes, por lo que este primer resultado, a priori, nos anima a revisar a fondo la consistencia de la matriz de comparación. A tal efecto, existen métricas específicas y mucho más robustas que el método de las diferencias mostrado arriba, para evaluar la consistencia de la matriz de comparación, como es por ejemplo la ratio o razón de consistencia $CR$, analizada en la próxima sección.

### Medición y representación de la consistencia de las respuestas

La métrica convencional para evaluar la consistencia de las respuestas aportadas por las personas consultadas es la razón de consistencia, la cual viene dada por la fórmula siguiente:

$$CR = \bigg(\frac{\lambda_{max}-n}{n-1}\bigg)\bigg(\frac{1}{RI}\bigg)$$

donde $CR$ es la razón de consistencia, $\lambda_{max}$ es el valor propio más grande del vector de comparación por parejas, $n$ es el número de atributos, en nuestro caso, $8$, y $RI$ es un índice aleatorio que puede ser provisto por el usuario a partir de simulaciones, que con el paquete `ahpsurvey` se puede generar mediante la función `ahp.ri`. El conjunto de $RI$ a continuación se generó a partir de `ahp.ri` con 500000 simulaciones (ver tabla \@ref(tab:suprisimuladospaqahpsurvey)), y están contenidas en la viñeta principal de la documentación del paquete `ahpsurvey` [@cho2019ahpsurvey]:

```{r suprisimuladospaqahpsurvey}
ri_sim <- t(data.frame(RI = c(0.0000000, 0.0000000, 0.5251686, 0.8836651, 1.1081014, 1.2492774, 1.3415514, 1.4048466, 1.4507197, 1.4857266, 1.5141022,1.5356638, 1.5545925, 1.5703498, 1.5839958)))
colnames(ri_sim) <- 1:15
ri_sim %>%
  kable(format = 'html', escape = F, booktabs = T, digits = 2,
        caption = 'Índices aleatorios generados por la función ahp.ri con 500000 simulaciones para 1 a 15 atributos') %>%
  kable_styling(bootstrap_options = c("hover", "condensed"), full_width = T)
```

Para fines de impresión, la tabla sólo muestra dos dígitos, pero en el caso concreto de 8 atributos, el $RI$ a usar sería `r round(ri_sim[8],7)`. Adicionalmente, comprobamos este resultado por nuestra cuenta. Para ello usamos la función `ahp.ri` y generamos un $RI$ con 10000 simulaciones para 8 atributos (argumento `dim` de la referida función), fijando la aleatorización en el número 99.

```{r supprobandori}
tiempo_10k <- system.time(probandoRI <- ahp.ri(nsims = 10000, dim = 8, seed = 99))
```

El tiempo de cómputo fue relativamente pequeño (\~ `r round(tiempo_10k[[3]], 0)` segundos) y el resultado para $RI$ es `r round(probandoRI, 7)`, el cual se aproxima bastante al generado por @cho2019ahpsurvey (tabla \@ref(tab:suprisimuladospaqahpsurvey)). Si generásemos un $RI$ con 500000 simulaciones, nos tomaría al menos un minuto y medio en una PC de altas prestaciones (o varios minutos en una PC común), y el resultado sería bastante parecido al mostrado por @cho2019ahpsurvey, por lo que nos parece conveniente usar este último ($RI=1.4048466$).

```{r supdefri}
RI <- ri_sim[8]
```

Con este índice aleatorio, calculamos la razón de consistencia `CR` de las respuestas aportadas por cada persona consultada, mediante la función `ahp.cr` aplicada a la matriz de comparación en parejas. La tabla \@ref(tab:suprazondeconsistencia) resume el cómputo de esta métrica.

```{r suprazondeconsistencia}
cr <- matriz_ahp %>% ahp.cr(atts = names(variables), ri = RI)
data.frame(`Persona consultada` = seq_along(cr), CR = cr, check.names = F) %>%
  estilo_kable(titulo = 'Razones de consistencia (consistency ratio) por persona consultada',
               cubre_anchura = F) %>% 
  kable_styling(position = 'left') %>% 
  column_spec(column = 1:2, width = "10em")
```

```{r supumbrales}
umbral_saaty <- 0.1
umbral_alterno <- 0.15
umbral <- ifelse(recod_repartida, umbral_alterno, umbral_saaty)
```

Saaty demostró que cuando el $CR$ es superior a un umbral rígido de `r umbral_saaty`, la elección se considera inconsistente [@saaty1977]. **En nuestro caso, elegimos el umbral de `r umbral` para** $CR$, por lo que obtuvimos un total de `r sum(cr<=umbral)` valoraciones consistentes (personas consultadas números `r paste(which(cr<=umbral), collapse=', ')`) y `r sum(cr>umbral)` inconsistentes (personas números `r paste(which(cr>umbral), collapse=', ')`) (comparar con tabla \@ref(tab:suprazondeconsistencia)).

```{r supnumconsistinconsist}
table(ifelse(cr <= umbral, 'Consistente', 'Inconsistente')) %>% as.data.frame() %>% 
  setNames(nm = c('Tipo', 'Número de cuestionarios')) %>% 
  estilo_kable(titulo = 'Número de cuestionarios según consistencia',
               cubre_anchura = F) %>% 
  kable_styling(position = 'left') %>% 
  column_spec(column = 1:2, width = "10em")
```

Calculamos también las preferencias o prioridades asignadas por cada persona consultada, así como la ponderación correspondiente (peso, valor propio dominante), mediante la función `ahp.indpref`, que proporciona una relación detallada. La visualización de los diagramas de cajas, gráficos de violín (que son gráficos de densidad en espejo acompañando al diagrama de cajas) y los puntos (*jitter*), todos superpuestos, resulta útil para visualizar la heterogeneidad de las ponderaciones de cada persona consultada por atributo. Aunque esta visualización es más conveniente para un número grande de personas consultadas, la visualización con nuestros datos es bastante expresiva.

```{r supatributopesocrboxplot, fig.cap='Preferencias individuales por atributo y ratio de consistencia', out.width='100%'}
cr_indicador <- cr %>% 
  data.frame() %>% 
  mutate(`Persona consultada` = seq_along(cr), `CR indicador` = as.factor(ifelse(cr <= umbral, 1, 0))) %>%
  select(`CR indicador`, `Persona consultada`)

matriz_ahp %>% 
  ahp.indpref(names(variables), method = "eigen") %>% 
  mutate(`Persona consultada` = seq_along(cr)) %>%
  left_join(cr_indicador, by = 'Persona consultada') %>%
  gather(-matches('Persona|CR'), key = "var", value = "pref") %>%
  ggplot(aes(x = var, y = pref)) + 
  geom_violin(alpha = 0.6, width = 0.8, color = "transparent", fill = "gray") +
  geom_jitter(alpha = 0.6, height = 0, width = 0.1, aes(color = `CR indicador`)) +
  geom_boxplot(alpha = 0, width = 0.3, color = "#808080") +
  scale_x_discrete("Atributo", labels = stringr::str_wrap(variables[sort(names(variables))], width = 10)) +
  scale_y_continuous("Peso (valor propio dominante)", 
                     labels = scales::percent, 
                     breaks = c(seq(0,0.7,0.1))) +
  guides(color=guide_legend(title=NULL)) +
  scale_color_discrete(breaks = c(0,1),
                       type = c("#F8766D", "#00BA38"),
                       labels = c(paste("CR >", umbral), 
                                  paste("CR <", umbral))) +
  labs(NULL, caption = paste("n =", nrow(tabla_col_renom), ",", "CR promedio =",
                           round(mean(cr),3))) +
  theme_minimal() +
  theme(legend.position = 'bottom', axis.text.x = element_text(size = 7))
```

La figura \@ref(fig:supatributopesocrboxplot) resume las preferencias asignadas por las personas consultadas, con indicación de la consistencia de las mismas. Las dos estacionalidades, térmica y pluviométrica, así como las horas de insolación debidas a terreno y la elevación, reunen la mayor parte de las preferencias de respuestas consistentes (puntos verdes); nótese que se han incluido las preferencias de respuestas inconsistentes también (puntos rojos). Por otra parte, los atributos que recibne menor ponderación son distancias a accesos y a cuerpos de agua, heterogeneidad de hábitat y pendiente.

### Evaluación de autocorrelación y proximidad

TODO

## Flujo de procesamiento completo AHP sin diagnósticos intermedios

```{r supflujocompletoahp}
flujo_completo_ahp <- ahp(df = tabla_col_renom[, col_ord], 
                          atts = names(variables), 
                          negconvert = TRUE, 
                          reciprocal = TRUE,
                          method = 'eigen', 
                          aggmethod = "geometric", 
                          qt = 0.2,
                          censorcr = umbral,
                          agg = TRUE)
flujo_completo_ahp
```
